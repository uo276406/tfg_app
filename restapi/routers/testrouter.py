from fastapi import APIRouter, status, Depends, HTTPException
from users.usersmanager import fastapi_users
from repository.testrepository import insert_test, get_tests_by_user, get_test_by_id, update_test_status
from repository.questionsrepository import insert_question, get_questions_by_test
from repository.optionsrepository import insert_option, get_options_by_question
from repository.teststudentrepository import update_test_student, get_students_by_test
from corrector.testcorrector import TestCorrector
from models.user import User
from pydantic import BaseModel
import uuid
from human_id import generate_id

router = APIRouter()

# Modelos: Request --------------------------------------------------

class Option(BaseModel):
    value: str
    correct: bool


class Question(BaseModel):
    question: str
    options: list[Option]


class Test(BaseModel):
    questions: list[Question]
    jump: bool
    feedback: bool


class TestCheck(BaseModel):
    testId: str
    studentId: str
    selection: list[int]


class TestStatus(BaseModel):
    id: str
    open: bool


# This is a FastAPI dependency that checks if the user is authenticated.
current_active_user = fastapi_users.current_user(active=True)


@router.post("/add", status_code=status.HTTP_201_CREATED, description="Add new test generated by the user based on the questions", response_description="Add new test generated by the user")
async def add_test(test: Test, user: User = Depends(current_active_user)):
    test_id = str(generate_id(word_count=4, separator="-"))
    new_test = {"id": test_id, "user_id": str(user.id), "jump": test.jump, "feedback": test.feedback}
    await insert_test(new_test)
    for question in test.questions:
        question_id = str(uuid.uuid4())
        await insert_question(question_id, question.question, test_id)
        for option in question.options:
            await insert_option({"id": str(uuid.uuid4()), "value": option.value, "is_correct": option.correct, "question_id": question_id})
    return {"id": test_id, "detail": "Test created successfully"}


@router.get("/find", status_code=status.HTTP_200_OK, description="Get all the test that one user has generated", response_description="Find all tests generated by the user")
async def find_user_tests(user: User = Depends(current_active_user)):
    res = []
    tests_found = await get_tests_by_user(user.id)
    for test in tests_found:
        test_found = {"id": test.id, "user_id": test.user_id,
                      "open": test.open, "questions": []}
        questions_found = await get_questions_by_test(test.id)
        for question in questions_found:
            question_found = {"id": question.id, "question_text": question.question_text,
                              "test_id": question.test_id, "options": []}
            options_found = await get_options_by_question(question.id)
            for option in options_found:
                option_found = {"id": option.id, "value": option.value,
                                "is_correct": option.is_correct, "question_id": option.question_id}
                question_found["options"].append(option_found)
            test_found["questions"].append(question_found)
        res.append(test_found)
    return res


@router.get("/{test_id}", status_code=status.HTTP_200_OK, description="Get specific test questions and posible options")
async def get_test(test_id: str):
    test_found = await get_test_by_id(test_id)
    if test_found == None:
        raise HTTPException(status_code=200, detail="Test not found")
    if test_found.open == False:
        raise HTTPException(status_code=200, detail="Test is closed")
    else:
        test_found = {"questions": [], "jump": test_found.jump, "feedback": test_found.feedback}
        questions_found = await get_questions_by_test(test_id)
        for question in questions_found:
            question_found = {"id": question.id,
                              "question_text": question.question_text, "options": []}
            options_found = await get_options_by_question(question.id)
            for option in options_found:
                option_found = {"value": option.value}
                question_found["options"].append(option_found)
            test_found["questions"].append(question_found)
        return test_found


@router.post("/check", status_code=status.HTTP_201_CREATED, description="Checks the test done by the student")
async def test_ckeck(test_check: TestCheck):
    test_found = await get_test_by_id(test_check.testId)
    if test_found == None:
        raise HTTPException(status_code=200, detail="Test not found")
    elif test_found.open == False:
        raise HTTPException(status_code=200, detail="Test is closed")
    else:
        # Busca el test
        test_found = {"questions": []}
        questions_found = await get_questions_by_test(test_check.testId)
        for question in questions_found:
            question_found = {
                "question_text": question.question_text, "options": []}
            options_found = await get_options_by_question(question.id)
            for option in options_found:
                option_found = {"value": option.value,
                                "is_correct": option.is_correct}
                question_found["options"].append(option_found)
            test_found["questions"].append(question_found)
        # Corrige el test pregunta por pregunta
        test_corrector = TestCorrector()
        res = test_corrector.correct(test_found, test_check)
        await update_test_student(test_check.testId, test_check.studentId, res["base10_score"], True)
        return res


@router.get("/find/results", status_code=status.HTTP_200_OK, description="Get all the test and the results of the users", response_description="Find all tests generated by the user")
async def find_user_tests_results(user: User = Depends(current_active_user)):
    res = []
    tests_found = await get_tests_by_user(user.id)
    for test in tests_found:
        test_found = {"id": test.id, "created_at": test.created_at,
                      "open": test.open, "students": []}
        students_found = await get_students_by_test(test.id)
        for student in students_found:
            student_found = {"id": student.student_id,
                             "score": student.score, "finished": student.finished}
            test_found["students"].append(student_found)
        res.append(test_found)
    return res


@router.post("/changestatus", status_code=status.HTTP_200_OK, description="Modifies the state of the test")
async def add_test(test: TestStatus, user: User = Depends(current_active_user)):
    await update_test_status(test.id, test.open)
    return {"detail": "Test status updated"}
